{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Maria Elena\\\\Desktop\\\\Programaci\\xF3n\\\\Bluuweb\\\\Next\\\\ontime\\\\components\\\\New\\\\context\\\\context.js\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { Component } from \"react\";\nimport axios from \"axios\"; // .createContext for our global state management rather than each individual compoents\n\nconst Context = React.createContext(); // 'action' will be an object, and it will be a type; so that type we want to be evaluated\n// reducer to evaluate the action type\n\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case \"DELETE_CONTACT\":\n      return _objectSpread(_objectSpread({}, state), {}, {\n        // filter out the contact that needs to be filtered out\n        contacts: state.contacts.filter((contact // payload is just some data we want to send along with our action, sending 'id' as the payload\n        ) => contact.id !== action.payload)\n      });\n\n    case \"ADD_CONTACT\":\n      return _objectSpread(_objectSpread({}, state), {}, {\n        // filter out the contact that needs to be filtered out\n        // Take 'contacts' which is the array of o\n        contacts: [action.payload, ...state.contacts]\n      });\n\n    case \"UPDATE_CONTACT\":\n      return _objectSpread(_objectSpread({}, state), {}, {\n        contacts: state.contacts.map(contact => contact.id === action.payload.id ? contact = action.payload : contact)\n      });\n\n    default:\n      return state;\n  }\n};\n\nexport class Provider extends Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", {\n      contacts: [],\n      // When we have a consumer, it consume their entire state because that's what we're passing in.\n      // We should be able to access 'dispatch' anywhere\n      dispatch: action => this.setState(state => reducer(state, action))\n    });\n  }\n\n  async componentDidMount() {\n    const res = await axios.get(\"https://jsonplaceholder.typicode.com/users\");\n    this.setState({\n      contacts: res.data\n    });\n  }\n\n  render() {\n    // We pass in the entire state so we can use it anywhere in our app, including props and functions\n    return __jsx(Context.Provider, {\n      value: this.state,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 62,\n        columnNumber: 13\n      }\n    }, this.props.children);\n  }\n\n} // We then export a 'consumer', because we have a 'provider' so consumer can access state\n\nexport const Consumer = Context.Consumer;","map":{"version":3,"sources":["C:/Users/Maria Elena/Desktop/ProgramaciÃ³n/Bluuweb/Next/ontime/components/New/context/context.js"],"names":["React","Component","axios","Context","createContext","reducer","state","action","type","contacts","filter","contact","id","payload","map","Provider","dispatch","setState","componentDidMount","res","get","data","render","props","children","Consumer"],"mappings":";;;;;;;;;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,OAAOC,KAAP,MAAkB,OAAlB,C,CAEA;;AACA,MAAMC,OAAO,GAAGH,KAAK,CAACI,aAAN,EAAhB,C,CAEA;AACA;;AACA,MAAMC,OAAO,GAAG,CAACC,KAAD,EAAQC,MAAR,KAAmB;AAC/B,UAAQA,MAAM,CAACC,IAAf;AACI,SAAK,gBAAL;AACI,6CAEOF,KAFP;AAEc;AACVG,QAAAA,QAAQ,EAAEH,KAAK,CAACG,QAAN,CAAeC,MAAf,CACN,CACIC,OADJ,CACY;AADZ,aAEKA,OAAO,CAACC,EAAR,KAAeL,MAAM,CAACM,OAHrB;AAHd;;AASJ,SAAK,aAAL;AACI,6CAEOP,KAFP;AAEc;AACV;AACAG,QAAAA,QAAQ,EAAE,CAACF,MAAM,CAACM,OAAR,EAAiB,GAAGP,KAAK,CAACG,QAA1B;AAJd;;AAMJ,SAAK,gBAAL;AACI,6CACOH,KADP;AAEIG,QAAAA,QAAQ,EAAEH,KAAK,CAACG,QAAN,CAAeK,GAAf,CAAmBH,OAAO,IAChCA,OAAO,CAACC,EAAR,KAAeL,MAAM,CAACM,OAAP,CAAeD,EAA9B,GACGD,OAAO,GAAGJ,MAAM,CAACM,OADpB,GAEEF,OAHI;AAFd;;AAQJ;AACI,aAAOL,KAAP;AA5BR;AA8BH,CA/BD;;AAiCA,OAAO,MAAMS,QAAN,SAAuBd,SAAvB,CAAiC;AAAA;AAAA;;AAAA,mCAE5B;AACJQ,MAAAA,QAAQ,EAAE,EADN;AAEJ;AACA;AACAO,MAAAA,QAAQ,EAAET,MAAM,IAAI,KAAKU,QAAL,CAAcX,KAAK,IAAID,OAAO,CAACC,KAAD,EAAQC,MAAR,CAA9B;AAJhB,KAF4B;AAAA;;AASpC,QAAMW,iBAAN,GAA0B;AACtB,UAAMC,GAAG,GAAG,MAAMjB,KAAK,CAACkB,GAAN,CACd,4CADc,CAAlB;AAIA,SAAKH,QAAL,CAAc;AAAER,MAAAA,QAAQ,EAAEU,GAAG,CAACE;AAAhB,KAAd;AACH;;AAEDC,EAAAA,MAAM,GAAG;AACL;AACA,WACI,MAAC,OAAD,CAAS,QAAT;AAAkB,MAAA,KAAK,EAAE,KAAKhB,KAA9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACK,KAAKiB,KAAL,CAAWC,QADhB,CADJ;AAKH;;AAxBmC,C,CA2BxC;;AACA,OAAO,MAAMC,QAAQ,GAAGtB,OAAO,CAACsB,QAAzB","sourcesContent":["import React, { Component } from \"react\";\nimport axios from \"axios\";\n\n// .createContext for our global state management rather than each individual compoents\nconst Context = React.createContext();\n\n// 'action' will be an object, and it will be a type; so that type we want to be evaluated\n// reducer to evaluate the action type\nconst reducer = (state, action) => {\n    switch (action.type) {\n        case \"DELETE_CONTACT\":\n            return {\n                // take the existing state, using spread operatior\n                ...state, // filter out the contact that needs to be filtered out\n                contacts: state.contacts.filter(\n                    (\n                        contact // payload is just some data we want to send along with our action, sending 'id' as the payload\n                    ) => contact.id !== action.payload\n                )\n            };\n        case \"ADD_CONTACT\":\n            return {\n                // take the existing state, using spread operatior\n                ...state, // filter out the contact that needs to be filtered out\n                // Take 'contacts' which is the array of o\n                contacts: [action.payload, ...state.contacts]\n            };\n        case \"UPDATE_CONTACT\":\n            return {\n                ...state,\n                contacts: state.contacts.map(contact => \n                    contact.id === action.payload.id \n                    ? (contact = action.payload)\n                    : contact\n                )\n            };\n        default:\n            return state;\n    }\n};\n\nexport class Provider extends Component {\n    // this is where we have our global state\n    state = {\n        contacts: [],\n        // When we have a consumer, it consume their entire state because that's what we're passing in.\n        // We should be able to access 'dispatch' anywhere\n        dispatch: action => this.setState(state => reducer(state, action))\n    };\n\n    async componentDidMount() {\n        const res = await axios.get(\n            \"https://jsonplaceholder.typicode.com/users\"\n        );\n\n        this.setState({ contacts: res.data });\n    }\n\n    render() {\n        // We pass in the entire state so we can use it anywhere in our app, including props and functions\n        return (\n            <Context.Provider value={this.state}>\n                {this.props.children}\n            </Context.Provider>\n        );\n    }\n}\n\n// We then export a 'consumer', because we have a 'provider' so consumer can access state\nexport const Consumer = Context.Consumer;\n"]},"metadata":{},"sourceType":"module"}